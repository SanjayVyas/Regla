/**
 *-----------------------------------------------------------------------------
 * File:      Engine.cs
 * Project:   Regla
 * Author:    Sanjay Vyas
 *
 * RulesEngine module is the core
 *      RulesEngine -> Stores a list of rules and executes them
 *      EngineAttributes -> Keeps a set of options 
 *          (object to operate on, output object, options etc)
 *-----------------------------------------------------------------------------
 * Revision History
 *   [SV] 2019-Dec-19 11.34: Fixed bug in EngineAttrribute ctor
 *   [SV] 2019-Dec-19 4.12: Added RemoveRule(Rule)
 *   [SV] 2019-Dec-19 3.44: Converted Rules array to params in ctor of Engine
 *   [SV] 2019-Dec-19 3.18: Fixed bug on empty Rules array in Engine ctor
 *   [SV] 2019-Dec-19 3.09: Resolved ctor conflict for default arguments
 *   [SV] 2019-Dec-19 2.34: Fixed Engine Count which was incrementing twice
 *   [SV] 2019-Dec-19 2.09: Added AddOrRule method
 *   [SV] 2019-Dec-19 2.03: Added clearRules to remove all rules
 *   [SV] 2019-Dec-19 1.53: Added AddAndRule class
 *   [SV] 2019-Dec-19 1.14: Created
 *-----------------------------------------------------------------------------
 */

using System;
using System.Collections.Generic;

namespace Regla
{
    using RulesList = List<Rule>;
    using RuleMethod = Func<object, object, bool>;

    /**
     * EngineAttributes serves as a ParamObject for passing Engine data around
     * All parameters are kept optional, so that its easy for user to build th engine
     *      Name -> Instance name of the engine (user provided or autogenerated)
     *      StopOnException -> Global option to control whether execution stops on exception on any rule
     *      StopOnRuleFailure -> Global option to control whether execution stops if a rule returns false
     *      Component -> Object on which the rules will execute (provided by the user)
     *      Output -> Additional object, where the user may store the computation from rules
     * 
     *      StopOnXxxxx can be overridden by individual rules
     *      Component and Output are provided by the user, when creating the RuleEngine
     *      and will be passed back to user methods, when the rule runs
     * 
     */
    public class EngineAttributes : ReglaAttributes
    {
        private static int _engineCount = 0;
        public string Name { set; get; }
        public bool StopOnException { set; get; } = true;
        public bool StopOnRuleFailure { set; get; } = false;
        public object Component { set; get; } = null;
        public object Output { set; get; } = null;

        public EngineAttributes(object component = null, object output = null, string name = null, bool stopOnException = true, bool stopOnRuleFailure = false)
        {
            this.Component = component;
            this.Output = output;
            this.Name = (name == null ? "Engine_" + ++_engineCount : name);
            this.StopOnException = stopOnException;
            this.StopOnRuleFailure = stopOnRuleFailure;
        }

        public override string ToString()
        {
            return "\"EngineAttributes\": " + ReglaHelper.ToJson(this);
        }
    }

    /**
     * Core of Regla
     *      EngineAttributes -> Various options set by the user
     *      RulesList -> A list of rule methods provided by the user, which will be called back
     */
    public class RulesEngine
    {
        public EngineAttributes EngineAttributes { private set; get; }
        public RulesList RulesList { private set; get; } = new RulesList();

        public RulesEngine(EngineAttributes engineAttributes = null, params Rule[] rulesArray)
        {
            EngineAttributes = (engineAttributes == null ? new EngineAttributes() : engineAttributes);
            if (rulesArray != null)
                RulesList.AddRange(rulesArray);
        }

        public RulesEngine(object component, object output = null, string name = null, bool stopOnException = true, bool stopOnRuleFailure = false)
            => EngineAttributes = new EngineAttributes(component, output, name, stopOnException, stopOnRuleFailure);

        public override string ToString()
        {
            return "\"Engine\": " + ReglaHelper.ToJson(this);
        }

        /** 
         * Check for duplicate name before adding a new Rule with ruleName
         */
        private bool ruleExists(string ruleName)
        {
            return RulesList.Exists(item => item.RuleAttributes.Name.Trim().ToLower() == ruleName.Trim().ToLower());
        }

        /**
         * AddRule methods are FluentInterface
         * They return the RuleEngine reference, enabling cascading calls
         * e.g.
         *      ruleEngine.AddRule(firstRule).AddRule(secondRule).AddRule(thirdRule)
         */
        public RulesEngine AddRule(Rule rule)
        {
            var name = rule.RuleAttributes.Name;
            if (ruleExists(name))
                throw new Exception("Rule name " + name + " already exists.");
            RulesList.Add(rule);
            return this;
        }

        public RulesEngine AddRule(params Rule[] rules)
        {
            foreach (var rule in rules)
                AddRule(rule);
            return this;
        }

        /**
         * AddAndRule adds AndRule class which short circuits of false rule
         */
        public RulesEngine AddAndRules(string ruleName = null, params Rule[] rules)
        {
            return AddRule(new AndRule(ruleName, rules));
        }

        /**
         * AndOrRule adds OrRule class which short circuits on true rule
         */
        public RulesEngine AddOrRules(string ruleName = null, params Rule[] rules)
        {
            return AddRule(new OrRule(ruleName, rules));
        }

        /**
         * Remove Rule by name from the RulesList
         */
        public bool RemoveRule(string ruleName)
        {
            return 1 == RulesList.RemoveAll(rule => rule.RuleAttributes.Name.Trim().ToLower() == ruleName.Trim().ToLower());
        }

        /**
         * Remove Rule by method from the RulesList
         */
        public bool RemoveRule(RuleMethod ruleMethod)
        {
            return 1 == RulesList.RemoveAll(rule => rule.RuleMethod == ruleMethod);
        }

        public bool RemoveRule(Rule rule)
        {
            return RulesList.Remove(rule);
        }

        /**
         * Remove all rules belonging to a group
         */
        public int RemoveGroup(string groupName)
        {
            return RulesList.RemoveAll(rule => rule.RuleAttributes.Group.Trim().ToLower() == groupName.Trim().ToLower());
        }

        /**
         * Clear all rules from the RuleList
         */
        public int ClearRules()
        {
            int count = RulesList.Count;
            RulesList.Clear();
            return count;
        }

        /**
         * Core method for executing rules
         * It executes rules in the given list and stores attributes
         */
        private Result RunRules(RulesList rulesList, string executionType)
        {
            // We need to capture result of each rule in the list
            var ruleResultAttributesList = new List<RuleResultAttributes>();

            // Number of rules executed could be less, due to stoppin on failure
            int rulesExecutedCount = 0;

            foreach (var rule in rulesList)
            {
                bool runResult = false;
                Exception exception = null;

                // We do not want Exception to be propagated to caller, instead will will capture it
                try { runResult = rule.RuleMethod(EngineAttributes.Component, EngineAttributes.Output); }
                catch (Exception e) { exception = e; }
                finally { ruleResultAttributesList.Add(new RuleResultAttributes(rule, runResult, exception)); }

                rulesExecutedCount++;

                // Rule may fail due to global option or per-rule option
                if (exception != null && (EngineAttributes.StopOnException || rule.RuleAttributes.StopOnException))
                    return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, rule.RuleAttributes.Name, "Exception"), ruleResultAttributesList.ToArray());

                if (runResult == false && (EngineAttributes.StopOnRuleFailure || rule.RuleAttributes.StopOnRuleFailure))
                    return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, rule.RuleAttributes.Name, "RuleFailure"), ruleResultAttributesList.ToArray());
            }
            return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, null, null), ruleResultAttributesList.ToArray());
        }

        /**
         * Wrapper method, which calls internal RunRules
         * It basically passes the entire rule list
         */
        public Result RunAllRules()
        {
            return RunRules(RulesList, "All");
        }

        /**
         * Run rules with specified names only
         */
        public Result RunNamedRules(string[] ruleNames)
        {
            // Convert ruleNames array into trimmed lower case, so that we don't do in inside the loop
            var namedList = new RulesList();
            for (var i = 0; i < ruleNames.Length; i++)
                ruleNames[i] = ruleNames[i].Trim().ToLower();

            // If the current rule is listed in the ruleNames array, add to execution list
            foreach (var rule in RulesList)
            {
                if (Array.Exists(ruleNames, name => name == rule.RuleAttributes.Name.Trim().ToLower()))
                    namedList.Add(rule);
            }

            return RunRules(namedList, string.Join(", ", ruleNames));
        }

        /**
         * Rule can have a common group and we can run rules part of a group
         */
        public Result RunGroupRules(string groupName)
        {
            // Let's not do conversion inside the loop
            var groupList = new RulesList();
            groupName = groupName.Trim().ToLower();

            // If the rule's group matches the given group name, add to execution list
            foreach (var rule in RulesList)
            {
                if (rule.RuleAttributes.Group.Trim().ToLower() == groupName)
                    groupList.Add(rule);
            }

            return RunRules(groupList, groupName);
        }
    }
}