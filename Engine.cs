using System;
using System.Collections.Generic;

/**
 * This is the core of Regla
 * RulesEngine -> Stores a list of rules and executes them
 *      EngineAttributes -> Keeps a set of options (object to operate on, output object, options etc)
 */
namespace Regla
{
    using RulesList = List<Rule>;

    /**
     * EngineAttributes serves as a ParamObject for passing Engine data around
     * All parameters are kept optional, so that its easy for user to build th engine
     *      Name -> Instance name of the engine (user provided or autogenerated)
     *      StopOnException -> Global option to control whether execution stops on exception on any rule
     *      StopOnRuleFailure -> Global option to control whether execution stops if a rule returns false
     *      Component -> Object on which the rules will execute (provided by the user)
     *      Output -> Additional object, where the user may store the computation from rules
     * 
     *      StopOnXxxxx can be overridden by individual rules
     *      Component and Output are provided by the user, when creating the RuleEngine
     *      and will be passed back to user methods, when the rule runs
     * 
     */
    public class EngineAttributes : ReglaAttributes
    {
        private static int _engineCount = 0;
        public string Name { set; get; } = "Engine_" + ++_engineCount;
        public bool StopOnException { set; get; } = true;
        public bool StopOnRuleFailure { set; get; } = false;
        public object Component { set; get; } = null;
        public object Output { set; get; } = null;

        public EngineAttributes(object component = null, object output = null, string name = null, bool stopOnException = true, bool stopOnRuleFailure = false)
        {
            this.Component = component;
            this.Output = Output;
            this.Name = (name == null ? "Engine_" + ++_engineCount : name);
            this.StopOnException = stopOnException;
            this.StopOnRuleFailure = stopOnRuleFailure;
        }

        public override string ToString()
        {
            return "\"EngineAttributes\": " + ReglaHelper.ToJson(this);
        }

    }

    /**
     * Core of Regla
     *      EngineAttributes -> Various options set by the user
     *      RulesList -> A list of rule methods provided by the user, which will be called back
     */
    public class RulesEngine
    {
        public EngineAttributes EngineAttributes { private set; get; }
        public RulesList RulesList { private set; get; } = new RulesList();

        public RulesEngine(EngineAttributes engineAttributes = null, Rule[] rulesArray = null)
        {
            EngineAttributes = (engineAttributes == null ? new EngineAttributes() : engineAttributes);
            RulesList.AddRange(rulesArray);
        }

        public RulesEngine(object component = null, object output = null, string name = null, bool stopOnException = true, bool stopOnRuleFailure = false)
            => EngineAttributes = new EngineAttributes(component, output, name, stopOnException, stopOnRuleFailure);


        /**
         * AddRule methods are FluentInterface
         * They return the RuleEngine reference, enabling cascading calls
         * e.g.
         *      ruleEngine.AddRule(firstRule).AddRule(secondRule).AddRule(thirdRule)
         */
        public RulesEngine AddRule(Rule rule)
        {
            RulesList.Add(rule);
            return this;
        }

        public RulesEngine AddRule(Rule[] rules)
        {
            foreach (var rule in rules)
                AddRule(rule);
            return this;
        }

        /**
         * Core method for executing rules
         * It executes rules in the given list and stores attributes
         */
        private Result RunRules(RulesList rulesList, string executionType)
        {
            // We need to capture result of each rule in the list
            var ruleResultAttributesList = new List<RuleResultAttributes>();

            // Number of rules executed could be less, due to stoppin on failure
            int rulesExecutedCount = 0;

            foreach (var rule in rulesList)
            {
                bool runResult = false;
                Exception exception = null;

                // We do not want Exception to be propagated to caller, instead will will capture it
                try { runResult = rule.RuleMethod(EngineAttributes.Component, EngineAttributes.Output); }
                catch (Exception e) { exception = e; }
                finally { ruleResultAttributesList.Add(new RuleResultAttributes(rule, runResult, exception)); }

                rulesExecutedCount++;

                // Rule may fail due to global option or per-rule option
                if (exception != null && (EngineAttributes.StopOnException || rule.RuleAttributes.StopOnException))
                    return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, rule.RuleAttributes.Name, "Exception"), ruleResultAttributesList.ToArray());

                if (runResult == false && (EngineAttributes.StopOnRuleFailure || rule.RuleAttributes.StopOnRuleFailure))
                    return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, rule.RuleAttributes.Name, "RuleFailure"), ruleResultAttributesList.ToArray());
            }
            return new Result(EngineAttributes, new RunResultAttributes(rulesList.Count, rulesExecutedCount, executionType, null, null), ruleResultAttributesList.ToArray());

        }

        /**
         * Wrapper method, which calls internal RunRules
         * It basically passes the entire rule list
         */
        public Result RunAllRules()
        {
            return RunRules(RulesList, "All");
        }

        /**
         * Run rules with specified names only
         */
        public Result RunNamedRules(string[] ruleNames)
        {
            // Convert ruleNames array into trimmed lower case, so that we don't do in inside the loop
            var namedList = new RulesList();
            for (var i = 0; i < ruleNames.Length; i++)
                ruleNames[i] = ruleNames[i].Trim().ToLower();

            // If the current rule is listed in the ruleNames array, add to execution list
            foreach (var rule in RulesList)
            {
                if (Array.Exists(ruleNames, name => name == rule.RuleAttributes.Name.Trim().ToLower()))
                    namedList.Add(rule);
            }

            return RunRules(namedList, string.Join(", ", ruleNames));
        }

        /**
         * Rule can have a common group and we can run rules part of a group
         */
        public Result RunGroupRules(string groupName)
        {
            // Let's not do conversion inside the loop
            var groupList = new RulesList();
            groupName = groupName.Trim().ToLower();

            // If the rule's group matches the given group name, add to execution list
            foreach (var rule in RulesList)
            {
                if (rule.RuleAttributes.Group.Trim().ToLower() == groupName)
                    groupList.Add(rule);
            }

            return RunRules(groupList, groupName);
        }

    }

}